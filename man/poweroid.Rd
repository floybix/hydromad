\name{poweroid}
\Rdversion{1.1}
\alias{poweroid}
\title{
  Poweroid geometry (cones, paraboloids, etc).
}
\description{
  Poweroid geometry (cones, paraboloids, etc).
}
\usage{
poweroid(alpha = NULL, beta = NULL,
         V = NULL, H = NULL,
         A = if (!missing(r)) pi * r^2,
         r = if (!missing(A)) sqrt(A/pi),
         ...,
         rel.error = FALSE,
         objective = if (rel.error) ~ mean(abs((obs - mod)/obs))
                     else ~ mean(abs((obs - mod))),
         polish = FALSE, details = FALSE)
}
\arguments{
  \item{alpha}{
    scale parameter.
  }
  \item{beta}{
    shape parameter.
  }
  \item{V}{
    volume.
  }
  \item{H}{
    height.
  }
  \item{A}{
    area (of circular base).
  }
  \item{r}{
    radius (of circular base).
  }
  \item{\dots}{
    passed to \code{\link{optimize}} when fitting parameters.
    The following arguments apply only to the case of fitting parameters.
  }
  \item{rel.error}{
    if \code{TRUE}, consider errors as proportion of given observed
    values; otherwise consider the total error in original units. This
    affects the objective function as well as estimation of alpha.
  }
  \item{objective}{
    the objective function, as a formula or expression, referring to
    objects \code{obs} (observed data) and \code{mod} (fitted data).
  }
  \item{polish}{
    to apply \code{\link{nlminb}} when fitting parameters.
  }
  \item{details}{
    to return calibration details when fitting parameters.
  }
}
\details{
  A poweroid is a generalisation of a cone, paraboloid (3D parabola),
  etc.

  A poweroid is defined by the surface of rotation (around the height
  axis) of the curve:
  \deqn{H = \alpha * r ^ \beta}{H = alpha * r ^ beta}

  where H is height, r is radius, and alpha and beta are parameters.

  Then, as special cases,
  \describe{
    \item{\code{beta = 1}}{ corresponds to a cone. }
    \item{\code{beta = 2}}{ corresponds to a paraboloid. }
    \item{\code{beta = 4}}{ is sometimes called a quartoid. }
    \item{\code{beta < 1}}{ has a funnel shape. }
  }

  The \code{poweroid} function can be used in three different ways:

  If \code{alpha} and \code{beta} are specified, any one of \code{V},
  \code{H}, \code{A} or \code{r} can be used to calculate all the
  others.

  If \code{beta} is specified, any two of \code{V},
  \code{H}, or \code{A / r} can be used to derive \code{alpha}.

  Otherwise, any two of \code{V}, \code{H}, or \code{A / r} can be used
  to estimate \code{alpha} and \code{beta}. In this case, multiple
  values must be given for each measurement, and the parameters are
  fitted to these using \code{\link{optimize}}. (Specifically, the beta
  parameter is fitted, while the alpha parameter is derived from beta on
  each iteration.)

  The examples below demonstrate the different shapes and depth
  distributions that are possible.
}
\value{
  If \code{alpha} and \code{beta} are specified, a \code{data.frame}
  with columns \code{V}, \code{H}, \code{A} and \code{r}.

  Otherwise, a list with components \code{alpha} and \code{beta}.
}
\references{
  \url{http://mathworld.wolfram.com/Paraboloid.html}

  \url{http://mathworld.wolfram.com/Poweroid.html}
}
\author{
Felix Andrews \email{felix@nfrac.org}
}
\seealso{
  \code{\link{swimp}},
  \code{\link{convertFlow}}
}
\examples{
## USE CASE 1: specified parameters

## A cone with height H and slope alpha
poweroid(H = 1:10, alpha = 2, beta = 1)

## Take four different shapes: beta = 4 / 2 / 1 / 0.5
## Calculate geometry, given Volume values from 0 to 100.
shapedat <- list(
  `beta=4 (quartoid)` = poweroid(V = (0:1000)/10, beta = 4, alpha = 0.0078125),
  `beta=2 (paraboloid)` = poweroid(V = (0:1000)/10, beta = 2, alpha = 0.125),
  `beta=1 (cone)` = poweroid(V = (0:1000)/10, beta = 1, alpha = 0.5),
  `beta=1/2 (funnel)` = poweroid(V = (0:1000)/10, beta = 0.5, alpha = 1))

## Plot cross sections, all with V = 100 and intersecting at r = 4:

shapedf <- do.call(make.groups, shapedat)

xyplot(c(H, H) ~ c(-r, r), shapedf,
  groups = rep(which, 2), type = "a", lwd = 2,
  xlab = "radius", ylab = "height",
  auto.key = list(lines=TRUE, points=FALSE))

## Compare general form of depth distributions:

depthdat <- lapply(shapedat, transform,
  H = (1 - H / max(H)), A = 100 * A / max(A))
depthdf <- do.call(make.groups, depthdat)

xyplot(H ~ A | which, depthdf, as.table = TRUE,
  xlab = "cumulative area (percent)", ylab = "depth / max(depth)",
  panel = function(x, y, ...) {
    panel.grid(h = -1, v = -1)
    panel.polygon(c(x, 0), c(y, 0), col = grey(0.75),
                  border = "transparent")
    panel.xyplot(x, y, ...)
  },
  type = "l", par.settings = simpleTheme(lwd = 2))

## Compare effect of different alpha, with a fixed Volume V = 100
## beta is constant at 0.8

scaledat <- list(
  `alpha = 2` = poweroid(V = (0:1000)/10, beta = 0.8, alpha = 2),
  `alpha = 1` = poweroid(V = (0:1000)/10, beta = 0.8, alpha = 1),
  `alpha = 1/2` = poweroid(V = (0:1000)/10, beta = 0.8, alpha = 0.5),
  `alpha = 1/4` = poweroid(V = (0:1000)/10, beta = 0.8, alpha = 0.25))

scaledf <- do.call(make.groups, scaledat)

xyplot(c(H, H) ~ c(-r, r), scaledf,
  groups = rep(which, 2), type = "a", lwd = 2,
  xlab = "radius", ylab = "height",
  auto.key = list(lines=TRUE, points=FALSE))

depthdat <- lapply(scaledat, transform, H = max(H) - H)
depthdf <- do.call(make.groups, depthdat)

xyplot(H ~ A, groups = which, depthdf,
  xlab = "cumulative area", ylab = "depth",
  panel = function(...) {
    panel.superpose(..., panel.groups = function(x, y, ...)
      panel.polygon(c(x, 0), c(y, 0), col = grey(0.25), alpha = 0.25))
    panel.xyplot(...)
  },
  type = "l", par.settings = simpleTheme(lwd = 2),
  auto.key = list(lines = TRUE, points = FALSE))

## USE CASE 2: Derive alpha given beta.

poweroid(V = 1000, A = 20, beta = 2)
poweroid(V = 1000, H = 5, beta = 1.5)
## derive the alpha values used at the top of this section
poweroid(r = 4, H = 2, beta = c(4, 2, 1, 0.5))

## USE CASE 3: fit alpha and beta to given data

poweroid(V = c(100, 1000, 10000), A = c(5, 52, 127))
# --> alpha = 4.83, beta = 1.9
## simulate with these parameters to see how well they fit A:
poweroid(V = c(100, 1000, 10000), alpha = 4.83, beta = 1.9)
# --> A:  11.95  38.91 126.70

## try fitting again, based on relative error this time:
poweroid(V = c(100, 1000, 10000), A = c(5, 52, 127), rel.error=TRUE)
# --> alpha = 26.6, beta = 1.14
## simulate with these parameters to see how well they fit A:
poweroid(V = c(100, 1000, 10000), alpha = 26.6, beta = 1.14)
# --> A:   6.72  29.11 126.20

}
\keyword{ math }
\keyword{ optimize }
